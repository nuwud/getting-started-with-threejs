<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Three.js Ball</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      font-family: Arial, sans-serif;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      pointer-events: none;
      max-width: 300px;
    }
    
    h2 {
      margin-top: 0;
      color: #00FFFF;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Simple 3D Ball</h2>
    <p>Click and drag to rotate the ball</p>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
    
    // Set up scene, camera, renderer
    let scene, camera, renderer;
    let ball;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    
    function init() {
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 2;
      
      // Create lighting
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 1, 1);
      scene.add(light);
      
      const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
      light2.position.set(-1, -1, -1);
      scene.add(light2);
      
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      
      // Create ball with gradient
      createBall();
      
      // Set up event listeners
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mousedown', onMouseDown);
      window.addEventListener('mouseup', onMouseUp);
      window.addEventListener('resize', onWindowResize);
      
      // Start animation loop
      animate();
    }
    
    function createBall() {
      // Create gradient texture
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const context = canvas.getContext('2d');
      
      // Create gradient
      const gradient = context.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, canvas.width / 2
      );
      
      // Add gradient colors
      gradient.addColorStop(0, '#FF00FF'); // Pink at center
      gradient.addColorStop(0.5, '#8800FF'); // Purple in middle
      gradient.addColorStop(1, '#00FFFF'); // Cyan at edges
      
      // Fill with gradient
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      const texture = new THREE.CanvasTexture(canvas);
      
      // Create material
      const material = new THREE.MeshPhysicalMaterial({
        map: texture,
        transparent: true,
        opacity: 0.9,
        metalness: 0.2,
        roughness: 0.3,
        clearcoat: 0.5
      });
      
      // Create wireframe material
      const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      
      // Create geometry
      const geometry = new THREE.IcosahedronGeometry(1, 4);
      
      // Create meshes
      const mainMesh = new THREE.Mesh(geometry, material);
      const wireMesh = new THREE.Mesh(geometry, wireMaterial);
      
      // Create group to hold both meshes
      ball = new THREE.Group();
      ball.add(mainMesh);
      ball.add(wireMesh);
      
      scene.add(ball);
    }
    
    function onMouseMove(event) {
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        
        // Rotate the ball based on mouse movement
        ball.rotation.y += deltaMove.x * 0.01;
        ball.rotation.x += deltaMove.y * 0.01;
        
        previousMousePosition = {
          x: event.clientX,
          y: event.clientY
        };
      }
    }
    
    function onMouseDown(event) {
      isDragging = true;
      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }
    
    function onMouseUp() {
      isDragging = false;
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Gentle auto-rotation when not dragging
      if (!isDragging) {
        ball.rotation.x += 0.003;
        ball.rotation.y += 0.004;
      }
      
      renderer.render(scene, camera);
    }
    
    init();
  </script>
</body>
</html>